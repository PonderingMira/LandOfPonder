# Lab in Systems Programming [20465]

**About.** This is the second programming course. It teaches C language and teaches basic concepts such as memory handling. The course isn't laden except for the end of the semester, when a big final project has to be submitted. A significant portion of the grade is made of both the project and a final exam, with a smaller portion made of small assignments.

The project is an assembler written in C for a made-up assembly language. The material is good, the main book is a small book written by the creators of C, and it's straight to the point. Most of the learning was in my case made through the assignments, which all are coding exercises.


**My experience.** I enjoyed the course. It dealt with lower-level programming which I always wanted to grasp better. It wasn't busy during the semester, and the assignments were quite light. 

The final project was the most enjoyable part of the course. I took a two months window to play it safe and finished the project by myself in three weeks. Half of my time was dedicated to understanding the requirements, which was quite difficult. I read the outline many times until I finally understood what was required of me.

Then I created a skeleton of the project and started to code. Two weeks of intensive work were dedicated to the programming. I finished the duties of the other courses I took that semester, so the work on the project was my sole activity during that time.

The final project was about 1,500 code lines long, and at the last minute I 'tweaked' the project, resulting in a forgotten memory freeing, ultimately creating an error without my notice. Don't do that.


**Preliminaries.** Only 'Introduction to Computer Science and Java'.

**Focus Suggestion.** None. You may easily do all of the assignments.

**Personal Note.** Don't spend too much time on this course during the semester. It's easy, you may consider working harder on other courses you simultaneously take and not submitting assignments in this course.

Further, consider developing the final project on your own computer OS and not on an Ubuntu Virtual Machine. Occasionally transfer your work to Ubuntu to check if it runs as needed, but it was more efficient for me to develop on my Mac. When you finish the project, transfer it to the virtual machine, compile it, etc. 

I recommend working on Xcode on Mac. You can configure the makefile to work as needed and leave the terminal mess behind. The key advantage is the built-in interface debugger, easily operated, unlike gdb.
